import { app, BrowserWindow, ipcMain } from 'electron';
import { google } from 'googleapis';
import { authenticate } from '@google-cloud/local-auth';
import { OAuth2Client } from 'google-auth-library'; // Moved to top
import path from 'path';
import fs from 'fs';
import { FileEmailDraft } from './types';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

// Global constants
const SCOPES = ['https://www.googleapis.com/auth/gmail.compose'];
const CREDENTIALS_PATH = path.join(app.getAppPath(), 'src', 'credentials.json');
const TOKEN_PATH = path.join(app.getPath('userData'), 'token.json');

// --- WINDOW CREATION ---

const createWindow = (): void => {
  const mainWindow = new BrowserWindow({
    width: 1200, 
    height: 800,
    show: false, // Don't show immediately to avoid flickering
    icon: path.join(__dirname, './assets/icon.png'),
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      contextIsolation: true,
      nodeIntegration: false,
    },
  });

  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Maximize the window once created
  mainWindow.maximize(); 
  
  // Show the window now that it is maximized and content is loading
  mainWindow.show(); 

  // optional: mainWindow.webContents.openDevTools();
};

app.on('ready', createWindow);

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// --- AUTH HELPER FUNCTIONS ---

async function loadSavedCredentialsIfExist() {
  try {
    const content = fs.readFileSync(TOKEN_PATH, 'utf-8');
    const credentials = JSON.parse(content);
    return google.auth.fromJSON(credentials) as OAuth2Client;
  } catch {
    return null;
  }
}

async function saveCredentials(client: OAuth2Client) {
  const content = fs.readFileSync(CREDENTIALS_PATH, 'utf-8');
  const keys = JSON.parse(content);
  const key = keys.installed || keys.web;

  const payload = {
    type: 'authorized_user',
    client_id: key.client_id,
    client_secret: key.client_secret,
    refresh_token: client.credentials.refresh_token,
  };

  fs.writeFileSync(TOKEN_PATH, JSON.stringify(payload));
}

// This helper prevents writing the same auth logic twice
async function getAuthenticatedClient() {
  let auth = await loadSavedCredentialsIfExist();
  if (!auth) {
    auth = await authenticate({
      scopes: SCOPES,
      keyfilePath: CREDENTIALS_PATH,
    });
    await saveCredentials(auth);
  }
  return auth;
}

// --- IPC HANDLERS ---

// 1. Login
ipcMain.handle('google-login', async () => {
  // This helper handles checking for token or prompting user
  await getAuthenticatedClient();
});

// 2. Check status
ipcMain.handle('google-is-logged-in', async () => {
  const auth = await loadSavedCredentialsIfExist();
  return !!auth;
});

// 3. Logout
ipcMain.handle('google-logout', async () => {
  try {
    if (fs.existsSync(TOKEN_PATH)) {
      fs.unlinkSync(TOKEN_PATH); // Delete the credential file
    }
    return true;
  } catch (error) {
    console.error('Logout failed:', error);
    return false;
  }
});

// 4. Create Drafts
ipcMain.handle('create-drafts', async (_event, files: FileEmailDraft[]) => {
  try {
    // Reuse the helper logic
    const auth = await getAuthenticatedClient();

    const gmail = google.gmail({ version: 'v1', auth });

    for (const file of files) {
      await createDraft(gmail, file);
    }

    return `Successfully created ${files.length} drafts!`;
  } catch (error) {
    console.error('GMAIL ERROR:', error);
    throw error;
  }
});

// --- GMAIL DRAFT CONSTRUCTION ---

async function createDraft(gmail: any, fileData: FileEmailDraft) {
  // 1. Prepare Content
  const attachmentContent = fs.readFileSync(fileData.path).toString('base64');
  
  // We Base64 encode the HTML body to ensure Gmail renders it as HTML
  const bodyContent = Buffer.from(fileData.body ?? '').toString('base64');
  
  const boundary = 'foo_bar_baz';
  
  // 2. Construct the MIME message
  const rawMessage = 
    `To: ${fileData.to}\r\n` +
    `Cc: ${fileData.cc ?? ''}\r\n` +
    `Subject: ${fileData.subject ?? ''}\r\n` +
    `MIME-Version: 1.0\r\n` +
    `Content-Type: multipart/mixed; boundary="${boundary}"\r\n\r\n` +
    
    // -- HTML BODY PART --
    `--${boundary}\r\n` +
    `Content-Type: text/html; charset="UTF-8"\r\n` + 
    `Content-Transfer-Encoding: base64\r\n` + 
    `\r\n` + 
    `${bodyContent}\r\n\r\n` +
    
    // -- ATTACHMENT PART --
    `--${boundary}\r\n` +
    `Content-Type: application/octet-stream; name="${path.basename(fileData.path)}"\r\n` +
    `Content-Disposition: attachment; filename="${path.basename(fileData.path)}"\r\n` +
    `Content-Transfer-Encoding: base64\r\n\r\n` +
    `${attachmentContent}\r\n` +
    
    `--${boundary}--`;

  // 3. Final Encoding for Gmail API
  const encodedMessage = Buffer.from(rawMessage)
    .toString('base64')
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=+$/, '');

  // 4. Send
  await gmail.users.drafts.create({
    userId: 'me',
    requestBody: {
      message: {
        raw: encodedMessage,
      },
    },
  });
}